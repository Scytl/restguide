= RESTful Web Services

== What is REST?

[quote, Wikipedia]
Representational state transfer (REST) is an architectural style consisting of a coordinated set of architectural constraints applied to components, connectors, and data elements, within a distributed hypermedia system

Web service APIs that follow _REST_ architectural are known as RESTful Web Services.
They defines with these aspects:

* a base _URI_ to identify a resource
* an internet media type like _JSON_, _XML_, _image_.
* use of standard _HTTP_ methods such as _GET_, _POST_, _PUT_ or _DELETE_.
* hypertext links to reference state
* hypertext links to reference related resources

RESTful resources are identified by _URI_.
Depending on the form of the _URI_, more or less resources will be involved.
Let's see some examples of valid _URIs_ and their meaning.

[[valid_uri]]
[cols="2*", options="header"]
|===
|URI
|Description

m|/items
|Represents a collection of items

m|/items/name/Beer
|Represents  items with name Beer

m|/items/ordered
|Represents a collection of items that are ordered

m|/users/12/items
|Represents all the items for a user identified with 12
|===

As seen in <<valid_uri, previous table>>, _URI_ only are used to represent resources, but not what action (_verb_) to apply them.
Actions are set by _HTTP_ methods.

[cols="2*", options="header"]
|===
|HTTP methods
|Description

m|GET
|Get resource/s

m|POST
|Create a resource

m|PUT
|Update a resource if exists or create a new one

m|DELETE
|Delete a resource

m|HEAD
|HTTP headers are returned without content.

m|PATCH
|Apply a *set of changes* to the resource identified by the request's _URI_.
|===

So the combination of _HTTP_ method and _URI_ sets the operation to be executed and which resources will be affected.

[cols="2*", options="header"]
|===
|HTTP method resource URI
|Description

m|GET /items
|Gets a list of items

m|POST /items
|Create a new item

m|PUT /items/name/Beer
|Updates some data from items with name Beer

|DELETE /users/12/items
|Deletes all items of user with id 12
|===

[TIP]
====
* Use nouns to navigate through resources. For example `/users/12/items` is better than `/users/12/getItems`.
* Use subresources to refer to resource associations. For example `/users/12/items` to get all items from an specific user.
* Use query params for specific variations. For example `/users?age=25`. And path params only for identifiers.
* Add defaults for output format for just in case client does not specify it.
* Use plural nouns. For example use `/cars` instead of `/car`.
* _JSON_ document attributes in camel case form.
* In _PUT_ and _POST_ use body content to send data to be created or updated.
* By specification _PUT_ is a create or update operation. To avoid confusions _PUT_ should only update resources.
* Use _PATCH_ to execute a set of operations atomically. _PATCH_ can be used to change a resource partially or apply some operations on it.
====

.About PATCH
****
The _PATCH_ method requests that a set of changes to be applied to resource identified by the request's _URI_.
This set contains instructions describing how a resource currently residing on the origin server should be modified.

But _PATCH_ is not about sending an update value rather than the entire resource.

Next example is *wrong* and should be avoided:

[[bad-patch]]
[source, json]
----
PATCH /users/123

{ "email": "new.email@example.org" }
----

As mentioned, _PATCH_ should provide a description of changes to be applied.
You can think about it as a sequence of operations to apply to a resource.

RFC-6902 <<rfc6902>> defines a way for expression operations into a _JSON_ document.
Also it defines the 6 possible operations that can be executed:

test:: tests that a value at the target location is equal to a specified value
remove:: removes the value at the target location.
add::  if the target location specifies an array index, a new value is inserted into the array at the specified index. If the target location specifies an object member that does not already exist, a new member is added to the object.
replace:: replaces the value at the target location with a new value.
move:: removes the value at a specified location and adds it to the target location.
copy:: copies the value at a specified location to the target location.

A possible document may look like:

[source, json]
----
[
  { "op": "test", //<1>
    "path": "/a/b/c", //<2>
    "value": "foo" //<3>
  },
  { "op": "replace", "path": "/a/b/c", "value": 42 }
]
----
<1> Operation is set by using `op` attribute and as value the name of the operation.
<2> `path` defines where the operation is applied within resource.
<3> `value` to apply to given operation.

Previous <<bad-patch, patch example>> can be rewritten to:

[source, json]
----
PATCH /users/123 //<1>

[
  { "op": "replace", "path": "/email", "value": "new.email@example.org" } //<2>
]
----
<1> The resource to apply changes is a _user_ with id _123_.
<2> _email_ field of given _user_ is upadated to new _value_.

You can read more examples at http://tools.ietf.org/html/rfc6902#appendix-A
****

== Content Negotiation

RESTful Web Services can consume and produce different media type like _JSON_, _XML_ or any other valid type like plain text or binary.

Content negotiation allows different representations of a resource so that clients can consume what suits best for them.
The de-facto media type in RESTful Web Services is _JSON_, but client side must provide to server-side which media type is expecting.

There are two different approaches:

* Using _HTTP_ headers. `Accept` _HTTP_ header is used by the client to indicate which media type can handle. The `Content-Type` _HTTP_ header is used to indicate the _MIME_ type of the entity being sent by the server.
* Using _URL_ patterns. By using extension of the resource, server side knows which media type is expected by the client. For example `http://server/items.xml` to retrieve items in _XML_ form.

TIP: Use _HTTP_ headers approach instead of _URL_ patterns because _HTTP_ headers provide a clear separation between infrastructure and business.

[[versioning-rest]]
== Versioning

Probably RESTful _API_ will evolve during its lifetime.
For this reason we need a way to version the _API_ and provide some kind of back-compatibility so client can choose which version to use.
At least we should ensure that previous applications still works although a new version of the _API_ has been published.
There are several approaches to version _APIs_:

* Specifying in the _URI_ itself. For example `http://server/v2/items/12`. Note that '`v2`' is used as label to set which version of the _API_ client is expecting.
* Specifying as request parameter. For example `http://server/items/12?version=v2`. Note that in this case version is set as query parameter '`?version=v2`'.
* Specifying inside _HTTP_ header in `Accept` field or in a custom one. For example `Accept: application/vnd.server.v2+json` accepts the content produced in '`json`' and from '`version 2`'.

TIP: There is no clear approach about versioning. We are going to use the first one by setting in _URI_ the version of API.

== Response Codes

RESTful Web Services use _HTTP_ protocol as communication layer.
An _HTTP_ response must contain a response code so caller can inspect if the request it has done is correct or not.
RESTful Web Services should follow same rules and return a response code depending on the result of executed operation.
Next table summarize typical situations:

[cols="3*", options="header"]
|===
|Group
|Code
|Description

.4+|Success 2XX
m|200 OK
a|This returns content as a part of the response

m|201 Created
a|Used by _POST_. It must return `Location` header with resource id

m|202 Accepted
a|Used in asynchronous operations. It must return `Location` header specifying where the client can monitor for the request.

m|204 No Content
a|No content retuned as a part of the response. Used by _PUT_ when the resource is updated succesfully.

.2+|Redirectional 3XX
m|301 Permanent
a|Shows that all requests are directed to new location

m|302 Found
a|Shows that a resource already exists and is valid

.6+|Client Errors 4XX

m|400 Bad Request
a|Used when request cannot be processed due to syntax errors. For example malformed _JSON_.

m|401 Unauthorized
a|Used when request cannot be processed because of current user credentials

m|404 Not Found
a|Used when resource is not found or when an unauthenticated user request a secured resource

m|406 Not Acceptable
a|Used when the resource cannot *produce* the the _MIME_ type specified by the client

m|409 Conflict
a|Used when two resources are modified concurrently, in this case the latest modification should not be produced and return this error.

m|415 Unsupported Media Type
a|Used when the resource cannot *consume* the the _MIME_ type specified by the client

m|422 Unprocessable Entity
a|Used when request cannot be processed due to validation errors. Request body is well formed but semantically erroneous. For example an _email_ field without '`@`' character.

.2+|Server Errors 5XX
m|500 Internal Server error
a|Used as a generic error message

m|503 Service Unavailable
a|Used when the service is under maintainance or busy
|===

[NOTE]
====
Most of these codes are provided by default by container so we don't have to worry about them.
The most used response codes are '`2XX`', '`5XX`' and some '`4XX`'.
====

=== Error Codes

In case of error codes, a _JSON_ document can be sent back with information about the failure.
RESTful Web Service uses _HTTP_ error codes to notify them to caller.
Error codes are those starting with '`4XX`' or '`5XX`'.

When an error is sent to caller, it can contain a _JSON_ document as response body.
If a _JSON_ document is sent to explain the reason of the failure, it must follow next schema:

[source, json]
----
{
  "message": "Validation Failed", //<1>
  "errors": [ //<2>
    {
      "resource": "Book", //<3>
      "field": "title", //<4>
      "code": "field_mandatory" //<5>
    }
  ]
}
----
<1> Generic message explaining the error that has occured. This field is *mandatory*.
<2> List of specific errors. This section is *optional* and it _may_ be used when there are field validation errors. This subdocument has sense when an _HTTP 422_ is sent back.
<3> Name of the resource that contains the error.
<4> Field with the error.
<5> Code that represents the error. Frontend is the responsible of translating this code the user message in the configured locale.

[IMPORTANT]
====
There are some discussions about how to notify validation errors. We have based on rfc-4918 <<rfc4918>>, github API <<githubdev>> and blog post <<bennadel>> which argues that the best option is to use the _HTTP 422 code.
====

== Pagination

REST _APIs_ may return a huge number of resources per request.
To avoid overloading client side (and this is specially a problem in case of lightweight clients), we should paged each request with a certain number of items per request.
This is known as *Response pagination*.
Along with response is important to add some kind of metadata like current page, number of pages, total number of elements or a link to next set of results.

There are two possible approaches:

* Offset-based pagination which in general uses two query params named `offset` which sets which page to return and is zero-based and `limit` that sets the maximum number of results to be returned. For example `GET items?page=1&limit=50`.
* Time-based pagination which uses timestamps to paginate results between a specific timeframe. In this case `until` query param is used to point the end of the time range, and `since` for the beginning.

In case client can specify which field is used for sorting and direction, _sort_ query param must be used.
As value you set an optional character to set the direction of the order, '`+`' for ascending and '`-`' for descending, and finally the field name to sort.

For example `GET /books?sort=+name` for ascending direction or `GET /books?sort=-name` for descending.

TIP: If no direction is provided, ascending direction is the default one.

WARNING: Currently you can only sort elements by single field.

[source, json]
.Example of Offset-based response
----
{
  "entities": [ //<1>
    {
      "name": "foo",
        "age": 20
    },
    {
      "name": "bar",
      "age": 30
    }
  ],

  "pagination": { //<2>
    "limit": 100, //<3>
    "offset": 0, //<4>
    "count": 2, //<5>
  },
  "sort": { //<6>
    "orderDirection": "ASC", //<7>
    "orderFieldName": "id" //<8>
  }
}
----
<1> `entities` section adds all elements to be shown in current page.
<2> `pagination` is the parent element for all pagination elements.
<3> `limit` is the number of elements per page to retrieve.
<4> `offset` sets the current page (or offset). It is zero-based.
<5> `count` is the total number of items available.
<6> `sort` is the parent element for all sort parameters if elements are ordered..
<7> Direction of the order. _ASC_ for ascendant and _DESC_ for descendant.
<8> Ordered field name.


NOTE: Obviously Time-based pagination is not always possible, it will depend on the resource nature.

[WARNING]
====
Using offset pagination does not avoid returning duplicate records in case where additional resources are added between pagination requests.
This is something that depending on the number of pace of inserts and updates and the criticality of the information shown.

To avoid this problem a cursor-based pagination can be used.
Cursor-based pagination is pretty similar to offset approach but uses already known sequencial identifier of entity to know exactly at which point the latest result was returned.

You can read about real-time pagination in http://www.sitepoint.com/paginating-real-time-data-cursor-based-pagination/
====

== Filtering

== Field Selection

Sometimes client just need a few attributes instead of all attributes of a resource.
In endpoints that client can choose returned fields, a query param named _fields_ must be used.
And as value a list of comma-separated values of all fields to be returned.

For example `GET /books?fields=name,pages`.

TIP: In case of no _fields_ query param, the whole document should be returned to be compliant with REST _API_.

== Internationalization

RESTful Web Services can require to serve different responsed depending on the country and the locale.

Language negotiation is similar to content negotiation, so you can use diffrent approaches:

* Using `Accept-Language` _HTTP_ headers.
* Using a query parameter such as `locale`. For example `items/?locale=es`

TIP: Use _HTTP_ headers approach instead of query parameter approach because _HTTP_ headers provide a clear separation between infrastructure and business.

IMPORTANT: Any internacionalized response should set `Content-Language` _HTTP_ header in response as well.

== Existence checks

From prespective of frontend, sometimes you may need to check the existance of one resource before creating it.
For example to notify the problem to the user as soon as possible while filling a form, instead of after '`submit`' action.

As noted at <<headverb>>, *existence checks* are done by using _HEAD_ _HTTP_ method.

[quote, RFC - 2616, Section 9.4]
The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself.

So in cases where the content is not important, but the existance of the resource is, _HEAD_ is the _verb_ to be used.
We can do everything like a _GET_ and check the response code without the weight of the response body.

For example to know if a user with _login_ attribute (which is unique) is already created, next endpoint can be used:

`HEAD http://<host>/<application>/users?login=johnsmith`

The response may be a `200 OK` if the resource already exists or `404 OK` in case it has not been created yet.

== REST Polling

Sometimes an action takes too long to be completed in the context of a single _HTTP_ request.
Probably some kind of feedback should be provided to users, for example the number of processed elements, remaining elements or expected time to finish the task.
Asynchronous actions should only executed for _POST_, _PUT_, _PATCH_ or _DELETE_ _HTTP_ methods.

_HTTP_ protocol provides different ways to implement asynchronous callback action:

WebSockets:: It is a protocol providing full-duplex communications channels over a single TCP connection.
Server Sent Events (SSE):: Browser receives automatic updates from a server via HTTP connection and Server-Sent Events API.
Polling:: The client requests information from the server. Polling cycle is the time in which each element is monitored once.
Long Polling:: The client requests information from the server exactly as in normal polling, but in case of no information, the server side holds the connection until one become available.
WebHooks:: The source site makes an _HTTP_ request to the _URI_ configured for the webhook for given a given event.

All approaches offer PROs and CONs, but currently the *polling* way is going to be used because of simplification and easier implementation.

When an asynchronous operation is executed, instead of returning for example an _HTTP 201_ status code in case of _POST_ or _HTTP 204_ in case of _PUT_, an _HTTP 202_ code is returned with `Location` header specifying where the client can monitor the request.
The _HTTP 202_ is returned until defined _HTTP_ status code is returned.
For example an _HTTP 201_ in case of _POST_ or _HTTP 204_ in case of _PUT_.

Let's see an example of REST polling.
Creation of a resource may require validation of external services which can take several seconds.
Some feedback to the users could be provided about what steps are being executed.
To provide this feedback, client is going to use REST polling to know which step is being executed.

First step is sending a _POST_ to backend `POST http://<localhost>/<application>/books` and it will return a `HTTP 202 OK` with header's attribute `Location` set to `http://<localhost>/<application>/books/<tokenId>`.

Then client can send _GET_ requests to given '`Location`', in this case `http://<localhost>/<application>/books/<tokenId>`, and polling the resource until a status code not equal to _HTTP 202_ is received.

Each time an _HTTP 202_ is returned, a _JSON_ document must be sent in body response with information about the status of the task.
This document may follow next schema:

[source, json]
----
{
  "processed" : 18, //<1>
  "of" : 200, //<2>
  "estimatedTime" : 30 //<3>
}
----
<1> Number of elements that has been processed.
<2> Total number of elements.
<3> Optional parameter that sets the time in seconds remaining until all elements are processed.

TIP: `processed` and `of` are integers, but it may contain a null value in case it cannot be calculated.

[ditaa]
.Protocol Schema
....
        +-------------+                     /-------------\                 /-------------\
        |    Client   |                     |    /books   |                 |  /books/rfa |
        +-------------+                     \-------------/                 \-------------/
               |                                   |                                |
               |         +---------------+         |                                |
               |---------| POST {content}|-------->|                                |
               |         +---------------+         |                                |
               |                                   |                                |
               |       +-------------------+       |                                |
               |<------|      HTTP 202     |-------|                                |
               |       |Location /books/rfa|       |                                |
               |       +-------------------+       |                                |
               |                                                                    |
           +-->|                           +-------------------+                    |
           |   |---------------------------|        GET        |------------------->|
           |   |                           +-------------------+                    |
           |   |                                                                    |
           |   |                           +-------------------+                    |
           |   |                           |      HTTP 202     |                    |
  +----------+ |                           | {                 |                    |
  | HTTP 202 | |                           |   "processed" : 18|                    |
  +----------+ |<--------------------------|   "of" : 200,     |------------------->|
           |   |                           | }                 |                    |
           |   |                           +-------------+-----+                    |
           |   |                                                                    |
           +---|                                                                    |
               |                                                                    |
               |                           +-------------------+                    |
               |---------------------------|        GET        |------------------->|
               |                           +-------------------+                    |
               |                                                                    |
               |                           +-------------------+                    |
               |                           |      HTTP 201     |                    |
               |<--------------------------| Location /books/12|--------------------|
               |                           +-------------------+                    |
....

== Security
